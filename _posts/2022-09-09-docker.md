---
layout: post
title:  "Docker notes"
---


Docker is a tool for lightweight containerisation. What is containerisation, what makes docker lightweight 

VM vs containers
An application on a VM requires a guest OS and thus an underlying hypervisor to run. Hypervisor is used to create multiple machines on a host operating system and it manages virtual machines. These virtual machines have their own operating system and do not use the host's operating system. They have some space allocated. Containerisation is an effective method for deploying applications. A container encapsulates an application with its own operating environment. It can be placed on any host machine without any special configuration, removing the issue of dependencies. VM is hardware virtualization, whereas container is OS virtualization. Virtualization is the creation of a virtual version of something such as an operating system, server, storage device or network resources. Essentially, containerisation is a lightweight approach to virtualization. 

What is Docker?
Docker is a container platform that allows you to build, test and deploy applications quickly. A developer defines all the applications and its dependencies in a Dockerfile which is then used to build Docker image that defines a Docker container. Doing this ensures that your application will run in any environment.

Why use docker?
Using docker can help you ship your code faster, gives you control over your applications. You can deploy applications on containers that make it easier for them to be deployed, scaled, perform rollbacks and identify issues. It also helps in saving money by utilising resources. Docker-based applications can be seamlessly moved from local development machines to production deployments. You can use Docker for Microservices, Data processing, Continuous Integration and Delivery.

Architecture of docker

The role of the runtime is to start and stop containers. The low level runtime is called runc. The role of this runtime is to work with the operating system and start and stop the containers. The higher level runtime is called containerd. Its role is to manage runc, and advanced functionalities like connecting the container to the internet, pulling images from the internet etc. 
Docker engine is used to interact with Docker.

It uses a client/server architecture. The daemon listens to api requests, manages docker objects like containers, images, networks and volumes.
Orchestration allows us to manage containers automatically. It is useful for scaling infrastructure, restarting failed nodes, installing rolling updates etc.

A Dockerfile contains a set of docker instructions that provisions your operating system the way you like, and installs/configures all your software.
A Docker image is a compiled Dockerfile. It saves you time from rebuilding the Dockerfile everytime you need to run a container. And it's a way to hide your provision code.
A Docker container is the virtual operating system itself. You can ssh into it and run any commands you wish, as if it's a real environment. You can run thousands of containers from the same image.
You can think of Docker image as the class and container as the object.
Dockerfile - (Build) - Image - (Run) - Container


Open container initiative
The OCI is a Linux project to design open standards for containers.
OCI currently contains two specifications: the Runtime Specification (runtime-spec) and the Image Specification (image-spec).
OCI runtime-spec defines how to run the OCI image bundle as a container.
OCI image spec defines how to create an OCI Image, which includes an image manifest, a filesystem (layer) serialisation, and an image configuration.
Both docker and kubernetes being OCI compliant is what enabled kubernetes transition from using the docker runtime to the cri-o runtime.

Various container runtimes
containerd - A CNCF project, it manages the complete container lifecycle of it's host system that includes image management, storage and container lifecycle, supervision, execution and networking.
lxc - LXC provides OS level virtualization through a virtual environment that has its own process and network space, it uses linux cgroups and namespaces to provide the isolation.
runc - runc is a CLI tool for spawning and running containers according to the OCI specification. It was developed by Docker and donated to OCI as the first OCI runtime-spec compliant reference implementation.
cri-o: CRI-O is an implementation of the Kubernetes CRI (Container Runtime Interface) to enable using OCI compatible runtimes. It is a lightweight alternative to using Docker as the runtime for Kubernetes.

rkt - rkt is a container system developed by CoreOS as a lightweight and secure alternative to Docker. It is built based on an open container standard known as "App Container" or "appc" specification. Since rkt is secure by design, it is better for production deployment. In docker, if a user can break out of a container using a kernel exploit, the attacker can control the entire physical server and any attached data store. Of course Docker can be secured to prevent a user breaking out, but that requires additional time and effort. In contrast, rkt runs containers as un-privileged users, so that even if a user breaks out, they cannot affect other containers or take control of the server.

Docker images are built in layers. Each layer is an immutable file, but is a collection of files and directories. Data can be written to the last layer. Layers receive an ID, calculated via a SHA 256 hash of the layer contents. Thus, if the layer contents change, the SHA 256 hash changes as well. The image ID listed by docker commands is the first 12 characters of the hash. These hash values are referred to as tag names.

docker pull <image name> - Downloads a docker image.
